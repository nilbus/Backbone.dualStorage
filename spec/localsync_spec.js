// Generated by CoffeeScript 1.6.3
(function() {
  var Backbone, Store, localSync;

  Store = window.Store, Backbone = window.Backbone, localSync = window.localSync;

  describe('localSync', function() {
    describe('standard Backbone.sync methods', function() {
      describe('creating records', function() {
        it('creates records', function() {
          var create, model, ready, _ref;
          _ref = {}, ready = _ref.ready, create = _ref.create, model = _ref.model;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            create = spyOn(Store.prototype, 'create').andReturn($.Deferred().resolve(model));
            return localSync('create', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              })
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            return expect(create).toHaveBeenCalledWith(model);
          });
        });
        it('does not overwrite existing models with fetch(add: true) unless passed merge: true', function() {
          var create, ready, _ref;
          _ref = {}, ready = _ref.ready, create = _ref.create;
          runs(function() {
            var model;
            ready = false;
            create = spyOn(Store.prototype, 'find').andReturn($.Deferred().resolve({
              id: 1
            }));
            create = spyOn(Store.prototype, 'create').andReturn($.Deferred().resolve());
            model = new Backbone.Model({
              id: 1
            });
            return localSync('create', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              }),
              add: true
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          runs(function() {
            var model;
            ready = false;
            expect(create).not.toHaveBeenCalled();
            model = new Backbone.Model({
              id: 1
            });
            return localSync('create', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              }),
              add: true,
              merge: true
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            return expect(create).toHaveBeenCalled();
          });
        });
        return it('supports marking a new record dirty', function() {
          var create, dirty, model, ready, _ref;
          _ref = {}, ready = _ref.ready, create = _ref.create, model = _ref.model, dirty = _ref.dirty;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            create = spyOn(Store.prototype, 'create').andReturn($.Deferred().resolve(model));
            dirty = spyOn(Store.prototype, 'dirty').andReturn($.Deferred().resolve(model));
            return localSync('create', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              }),
              dirty: true
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            expect(create).toHaveBeenCalledWith(model);
            return expect(dirty).toHaveBeenCalledWith(model);
          });
        });
      });
      describe('reading records', function() {
        it('reads models', function() {
          var find, model, ready, _ref;
          _ref = {}, ready = _ref.ready, find = _ref.find, model = _ref.model;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            find = spyOn(Store.prototype, 'find').andReturn($.Deferred().resolve(model));
            return localSync('read', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              })
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            return expect(find).toHaveBeenCalledWith(model);
          });
        });
        return it('reads collections', function() {
          var findAll, ready, _ref;
          _ref = {}, ready = _ref.ready, findAll = _ref.findAll;
          runs(function() {
            findAll = spyOn(Store.prototype, 'findAll').andReturn($.Deferred().resolve());
            return localSync('read', new Backbone.Collection, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              })
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            return expect(findAll).toHaveBeenCalled();
          });
        });
      });
      describe('updating records', function() {
        it('updates records', function() {
          var model, ready, update, _ref;
          _ref = {}, ready = _ref.ready, update = _ref.update, model = _ref.model;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            update = spyOn(Store.prototype, 'update').andReturn($.Deferred().resolve(model));
            return localSync('update', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              })
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            return expect(update).toHaveBeenCalledWith(model);
          });
        });
        return it('supports marking an updated record dirty', function() {
          var dirty, model, ready, update, _ref;
          _ref = {}, ready = _ref.ready, update = _ref.update, model = _ref.model, dirty = _ref.dirty;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            update = spyOn(Store.prototype, 'update').andReturn($.Deferred().resolve(model));
            dirty = spyOn(Store.prototype, 'dirty').andReturn($.Deferred().resolve(model));
            return localSync('update', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              }),
              dirty: true
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            expect(update).toHaveBeenCalledWith(model);
            return expect(dirty).toHaveBeenCalledWith(model);
          });
        });
      });
      return describe('deleting records', function() {
        it('deletes records', function() {
          var destroy, model, ready, _ref;
          _ref = {}, ready = _ref.ready, destroy = _ref.destroy, model = _ref.model;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            destroy = spyOn(Store.prototype, 'destroy').andReturn($.Deferred().resolve(model));
            return localSync('delete', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              })
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            return expect(destroy).toHaveBeenCalledWith(model);
          });
        });
        return it('supports marking a dirty record destroyed', function() {
          var destroy, destroyed, model, ready, _ref;
          _ref = {}, ready = _ref.ready, destroy = _ref.destroy, destroyed = _ref.destroyed, model = _ref.model;
          runs(function() {
            model = new Backbone.Model({
              id: 1
            });
            destroy = spyOn(Store.prototype, 'destroy').andReturn($.Deferred().resolve(model));
            destroyed = spyOn(Store.prototype, 'destroyed').andReturn($.Deferred().resolve(model));
            return localSync('delete', model, {
              success: (function() {
                return ready = true;
              }),
              error: (function() {
                return ready = true;
              }),
              dirty: true
            });
          });
          waitsFor((function() {
            return ready;
          }), "A callback should have been called", 100);
          return runs(function() {
            expect(destroy).toHaveBeenCalledWith(model);
            return expect(destroyed).toHaveBeenCalledWith(model);
          });
        });
      });
    });
    describe('extra methods', function() {
      it('clears out all records from the store', function() {
        return runs(function() {
          var clear;
          clear = spyOn(Store.prototype, 'clear').andReturn($.Deferred().resolve());
          return localSync('clear', {}, {
            success: (function() {
              var ready;
              return ready = true;
            }),
            error: (function() {
              var ready;
              return ready = true;
            })
          });
        });
      });
      return it('reports whether or not it hasDirtyOrDestroyed', function() {
        return runs(function() {
          var clear;
          clear = spyOn(Store.prototype, 'hasDirtyOrDestroyed').andReturn($.Deferred().resolve());
          return localSync('hasDirtyOrDestroyed', {}, {
            success: (function() {
              var ready;
              return ready = true;
            }),
            error: (function() {
              var ready;
              return ready = true;
            })
          });
        });
      });
    });
    describe('callbacks', function() {
      it("sends the models's attributes as the callback response", function() {
        var model, response, _ref;
        _ref = {}, model = _ref.model, response = _ref.response;
        runs(function() {
          model = new Backbone.Model({
            id: 1
          });
          return localSync('create', model, {
            success: (function(resp) {
              return response = resp;
            })
          });
        });
        waitsFor((function() {
          return response;
        }), "A callback should have been called with a response", 100);
        return runs(function() {
          return expect(response).toBe(model.attributes);
        });
      });
      return it('ignores callbacks when the ignoreCallbacks option is set', function() {
        var callback, start, _ref;
        _ref = {
          start: new Date().getTime()
        }, start = _ref.start, callback = _ref.callback;
        runs(function() {
          var model;
          callback = jasmine.createSpy('callback');
          model = new Backbone.Model({
            id: 1
          });
          return localSync('create', model, {
            success: callback,
            error: callback,
            ignoreCallbacks: true
          });
        });
        waitsFor((function() {
          return new Date().getTime() - start > 5;
        }), 'Wait 5 ms to give the callback a chance to execute', 100);
        runs(function() {
          var model;
          start = false;
          expect(callback).not.toHaveBeenCalled();
          model = new Backbone.Model({
            id: 1
          });
          return localSync('create', model, {
            success: callback,
            error: callback
          });
        });
        return waitsFor((function() {
          return callback.wasCalled;
        }), 'The callback should have been called', 100);
      });
    });
    return describe('model parameter', function() {
      beforeEach(function() {
        return spyOn(Store.prototype, 'create').andReturn($.Deferred().resolve());
      });
      it('should not accept objects / attributes as model', function() {
        var attributes, call;
        attributes = {};
        call = function() {
          return localSync('create', attributes, {
            ignoreCallbacks: true
          });
        };
        return expect(call).toThrow();
      });
      it('should accept a backbone model as model', function() {
        var call;
        call = function() {
          return localSync('create', new Backbone.Model, {
            ignoreCallbacks: true
          });
        };
        return expect(call).not.toThrow();
      });
      it('should accept a backbone collection as model', function() {
        var call;
        call = function() {
          return localSync('create', new Backbone.Collection, {
            ignoreCallbacks: true
          });
        };
        return expect(call).not.toThrow();
      });
      it('should accept any object as model on extra method "clear"', function() {
        var call;
        call = function() {
          return localSync('clear', {}, {
            ignoreCallbacks: true
          });
        };
        return expect(call).not.toThrow();
      });
      return it('should accept any object as model on extra method "hasDirtyOrDestroyed"', function() {
        var call;
        call = function() {
          return localSync('hasDirtyOrDestroyed', {}, {
            ignoreCallbacks: true
          });
        };
        return expect(call).not.toThrow();
      });
    });
  });

}).call(this);
